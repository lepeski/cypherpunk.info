<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pDAI Timeline</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      min-height: 100%;
      background: #000;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #dceaff;
    }
    #canvas-container { position: fixed; inset: 0; }

    .content {
      position: relative;
      z-index: 1;
      width: min(96%, 1240px);
      margin: 1.25rem auto;
      background: rgba(4, 9, 22, 0.62);
      border: 1px solid rgba(132, 207, 255, 0.24);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45), 0 0 40px rgba(58, 133, 240, 0.2);
      backdrop-filter: blur(4px);
      padding: 1rem;
    }

    .header { display:flex; justify-content:space-between; gap:.8rem; flex-wrap:wrap; padding:.4rem .5rem .7rem; }
    .title {
      font-size: clamp(1.1rem, 2.7vw, 1.9rem);
      letter-spacing: .1em;
      text-transform: uppercase;
      background: linear-gradient(90deg, #54e5ff, #8f8bff 45%, #ca65ff 90%);
      -webkit-background-clip:text;
      color: transparent;
    }
    .subtitle { color:#a8c3e6; font-size:.86rem; }

    .chart-shell {
      position: relative;
      border-radius: 14px;
      border: 1px solid rgba(143, 200, 255, .2);
      background:
        radial-gradient(1200px 320px at 20% 0%, rgba(83, 105, 255, .15), transparent 60%),
        radial-gradient(920px 300px at 90% 100%, rgba(84, 229, 255, .12), transparent 70%),
        rgba(3, 12, 29, .6);
      overflow: hidden;
      padding: .65rem;
    }

    svg { width:100%; height:min(75vh,680px); min-height:420px; display:block; }

    .grid-line { stroke: rgba(130, 170, 230, 0.16); stroke-width: 1; }
    .axis-label { fill: rgba(175, 206, 242, .92); font-size: 12px; }
    .axis-title { fill: rgba(130, 188, 255, .95); font-size: 12px; letter-spacing: .06em; text-transform: uppercase; }
    .price-path {
      fill: none;
      stroke: url(#lineGradient);
      stroke-width: 3;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 0 10px rgba(109, 208, 255, 0.35));
    }
    .price-area { fill: url(#areaGradient); }
    .event-dot {
      fill: #d5f8ff;
      stroke: rgba(55, 160, 255, 0.95);
      stroke-width: 1.5;
      cursor: pointer;
      transition: r .15s ease;
    }
    .event-dot:hover { filter: drop-shadow(0 0 8px rgba(131, 217, 255, .95)); }

    .tooltip {
      position: absolute;
      pointer-events:none;
      min-width:230px;
      max-width:min(92vw,390px);
      background: rgba(8, 18, 40, .95);
      border: 1px solid rgba(134, 201, 255, .4);
      border-radius: 10px;
      color:#dbedff;
      padding:.66rem .78rem;
      font-size:.79rem;
      line-height:1.42;
      opacity:0;
      transform: translate(-50%, -110%) scale(.98);
      transition: opacity .13s ease, transform .13s ease;
      box-shadow: 0 14px 25px rgba(0,0,0,.4);
      z-index:4;
    }
    .tooltip.visible { opacity:1; transform: translate(-50%, -115%) scale(1); }
    .tooltip-date { color:#8fb4ff; font-size:.73rem; margin-bottom:.2rem; }
    .tooltip-price { color:#7ce4ff; font-size:.73rem; margin-bottom:.25rem; }

    .events-readout {
      margin-top: .75rem;
      display:grid;
      gap: .4rem;
      max-height: 180px;
      overflow: auto;
      padding-right: .2rem;
    }
    .event-item {
      background: rgba(6, 17, 38, 0.55);
      border: 1px solid rgba(97, 162, 220, 0.22);
      border-radius: 8px;
      padding: .45rem .6rem;
      color: #c8def7;
      font-size: .78rem;
    }
    .event-item b { color: #80e7ff; margin-right: .4rem; }

    @media (max-width: 760px) {
      .content { padding: .65rem; }
      .chart-shell { padding: .3rem; }
      svg { height: 66vh; min-height: 360px; }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <main class="content">
    <div class="header">
      <h1 class="title">pDAI Price Timeline</h1>
      <p class="subtitle">Rebuilt chart with wider scale and readable labels (hover markers for event titles)</p>
    </div>

    <section class="chart-shell">
      <svg id="timeline-chart" viewBox="0 0 1400 760" preserveAspectRatio="xMidYMid meet"></svg>
      <div id="tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>
    </section>

    <section id="event-list" class="events-readout" aria-label="Event list"></section>
  </main>

  <script src="https://pixijs.download/v6.5.8/pixi.min.js"></script>
  <script>
    const app = new PIXI.Application({ autoDensity:true, antialias:true, backgroundAlpha:0, width:window.innerWidth, height:window.innerHeight, resolution:window.devicePixelRatio||1 });
    document.getElementById('canvas-container').appendChild(app.view);
    app.ticker.maxFPS = 120;

    const CELL = 150;
    let cols = 0;
    let rows = 0;
    const grid = [];
    const nodes = [];
    const tmpG = new PIXI.Graphics();
    tmpG.beginFill(0xffffff); tmpG.drawCircle(0,0,1.5); tmpG.endFill();
    const nodeTex = app.renderer.generateTexture(tmpG);
    const COLORS = [0xaa00ff, 0x00aaff, 0x004de6];
    const lines = new PIXI.Graphics();
    lines.blendMode = PIXI.BLEND_MODES.ADD;
    app.stage.addChild(lines);

    let mouse = null;
    window.addEventListener('mousemove', e => mouse = { x:e.clientX, y:e.clientY });
    window.addEventListener('mouseleave', () => mouse = null);

    function initBackground() {
      cols = Math.ceil(app.screen.width / CELL);
      rows = Math.ceil(app.screen.height / CELL);
      grid.length = cols * rows;
      for (let i = 0; i < grid.length; i += 1) grid[i] = [];
      nodes.length = 0;
      app.stage.removeChildren();
      app.stage.addChild(lines);
      const count = Math.floor((app.screen.width * app.screen.height) / 15000 * 1.56);
      for (let i = 0; i < count; i += 1) {
        const n = new PIXI.Sprite(nodeTex);
        n.tint = COLORS[i % COLORS.length];
        n.anchor.set(0.5);
        n.x = Math.random() * app.screen.width;
        n.y = Math.random() * app.screen.height;
        n.vx = (Math.random() - 0.5) * 0.51;
        n.vy = (Math.random() - 0.5) * 0.51;
        n.ix = 0; n.iy = 0;
        app.stage.addChild(n);
        nodes.push(n);
      }
    }

    app.ticker.add(() => {
      lines.clear();
      for (let i = 0; i < grid.length; i += 1) grid[i].length = 0;
      for (const n of nodes) {
        const idx = Math.floor(n.y / CELL) * cols + Math.floor(n.x / CELL);
        if (grid[idx]) grid[idx].push(n);
      }
      for (const a of nodes) {
        const col = Math.floor(a.x / CELL);
        const row = Math.floor(a.y / CELL);
        for (let dy = -1; dy <= 1; dy += 1) for (let dx = -1; dx <= 1; dx += 1) {
          const c = col + dx, r = row + dy;
          if (c < 0 || c >= cols || r < 0 || r >= rows) continue;
          for (const b of grid[r * cols + c]) {
            if (a === b) continue;
            const dX = a.x - b.x, dY = a.y - b.y, dist = Math.hypot(dX, dY);
            if (dist < CELL) {
              lines.lineStyle(1.2, a.tint, ((CELL - dist) / CELL) * 0.4);
              lines.moveTo(a.x, a.y).lineTo(b.x, b.y);
            }
          }
        }
      }
      for (const n of nodes) {
        n.x += n.vx + n.ix; n.y += n.vy + n.iy;
        n.ix *= 0.6; n.iy *= 0.6;
        if (mouse) {
          const dX = n.x - mouse.x, dY = n.y - mouse.y, dist = Math.hypot(dX, dY);
          if (dist < CELL && dist > 0.1) {
            const f = (CELL - dist) / CELL;
            n.ix += (dX / dist) * 5 * f;
            n.iy += (dY / dist) * 5 * f;
          }
        }
        if (n.x < 0 || n.x > app.screen.width) n.vx *= -1;
        if (n.y < 0 || n.y > app.screen.height) n.vy *= -1;
      }
    });

    window.addEventListener('resize', () => {
      app.renderer.resize(window.innerWidth, window.innerHeight);
      initBackground();
      renderTimeline();
    });
    initBackground();

    const series = [
      { date: '2023-05-13', price: 1.0 },
      { date: '2023-06-30', price: 0.40 },
      { date: '2023-09-30', price: 0.09 },
      { date: '2023-12-31', price: 0.01 },
      { date: '2024-03-31', price: 0.001 },
      { date: '2024-06-30', price: 0.00012 },
      { date: '2024-11-30', price: 0.00006 },
      { date: '2025-01-26', price: 0.00003 },
      { date: '2025-02-20', price: 0.010 },
      { date: '2025-03-15', price: 0.034 },
      { date: '2025-03-24', price: 0.003 },
      { date: '2025-04-05', price: 0.015 },
      { date: '2025-04-12', price: 0.034 },
      { date: '2025-04-17', price: 0.000002 },
      { date: '2025-05-20', price: 0.0004 },
      { date: '2025-07-01', price: 0.0008 },
      { date: '2025-09-01', price: 0.00114 },
      { date: '2026-02-01', price: 0.00114 }
    ].map(p => ({ ...p, ts: new Date(p.date).getTime() }));

    const events = [
      { date: '2023-05-13', price: 1.0, title: '44.37B pDAI airdropped to ETH holders; MakerDAO contracts copied' },
      { date: '2023-05-13', price: 1.0, title: 'pDAI starts trading (no oracle / governance / active peg)' },
      { date: '2025-01-26', price: 0.00003, title: 'PSM exploit begins: minting via sellGem()' },
      { date: '2025-03-15', price: 0.034, title: '683M pDAI minted; $3.62M extracted in arbitrage window' },
      { date: '2025-03-24', price: 0.003, title: 'Post-spike crash and liquidity cascade phase' },
      { date: '2025-04-12', price: 0.034, title: 'ESM fire-function period; shutdown transition begins' },
      { date: '2025-04-17', price: 0.000002, title: '99.99% crash after ESM shutdown event' },
      { date: '2025-05-20', price: 0.0004, title: 'Community rebuild phase appears on-chain' },
      { date: '2025-06-01', price: 0.0009, title: 'BetterBank live on PulseChain; pDAI lending utility' },
      { date: '2025-09-01', price: 0.00114, title: 'Conference signal event; pDAI reaction +20%' },
      { date: '2026-02-01', price: 0.00114, title: 'Current state: ~877x from peg, liquidity + daily volume active' }
    ].map(e => ({ ...e, ts: new Date(e.date).getTime() }));

    function formatDate(ts) {
      return new Date(ts).toLocaleDateString(undefined, { year:'numeric', month:'short', day:'numeric' });
    }
    function formatPrice(v) {
      if (v >= 0.01) return `$${v.toFixed(4)}`;
      if (v >= 0.0001) return `$${v.toFixed(6)}`;
      return `$${v.toExponential(2)}`;
    }

    function renderTimeline() {
      const svg = document.getElementById('timeline-chart');
      const tooltip = document.getElementById('tooltip');
      const list = document.getElementById('event-list');
      const W = 1400, H = 760;
      const pad = { top: 28, right: 42, bottom: 62, left: 95 };
      const innerW = W - pad.left - pad.right;
      const innerH = H - pad.top - pad.bottom;

      const minTs = Math.min(...series.map(d => d.ts));
      const maxTs = Math.max(...series.map(d => d.ts));
      const minPrice = Math.min(...series.map(d => d.price));
      const maxPrice = Math.max(...series.map(d => d.price));
      const logMin = Math.log10(minPrice);
      const logMax = Math.log10(maxPrice);

      const x = (ts) => pad.left + ((ts - minTs) / (maxTs - minTs)) * innerW;
      const y = (price) => pad.top + (1 - ((Math.log10(price) - logMin) / (logMax - logMin))) * innerH;

      const linePts = series.map(d => ({ ...d, x: x(d.ts), y: y(d.price) }));
      const path = linePts.map((p,i) => `${i ? 'L':'M'} ${p.x.toFixed(2)} ${p.y.toFixed(2)}`).join(' ');
      const areaPath = `${path} L ${linePts[linePts.length-1].x.toFixed(2)} ${H-pad.bottom} L ${linePts[0].x.toFixed(2)} ${H-pad.bottom} Z`;

      const yTicks = [1, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001];
      const xTicks = [
        '2023-07-01','2024-01-01','2024-07-01','2025-01-01','2025-07-01','2026-01-01'
      ].map(d => ({ ts:new Date(d).getTime(), label:new Date(d).toLocaleDateString(undefined,{year:'2-digit',month:'short'}) }));

      svg.innerHTML = `
        <defs>
          <linearGradient id="lineGradient" x1="0" y1="0" x2="1" y2="0">
            <stop offset="0%" stop-color="#66e0ff" />
            <stop offset="45%" stop-color="#8f8bff" />
            <stop offset="100%" stop-color="#d36cff" />
          </linearGradient>
          <linearGradient id="areaGradient" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="rgba(118,170,255,0.4)" />
            <stop offset="100%" stop-color="rgba(118,170,255,0.02)" />
          </linearGradient>
          <clipPath id="plotClip"><rect x="${pad.left}" y="${pad.top}" width="${innerW}" height="${innerH}" /></clipPath>
        </defs>

        ${yTicks.filter(v => v >= minPrice && v <= maxPrice).map(v => `
          <line class="grid-line" x1="${pad.left}" y1="${y(v)}" x2="${W-pad.right}" y2="${y(v)}" />
          <text class="axis-label" x="14" y="${y(v)+4}">${formatPrice(v)}</text>
        `).join('')}

        ${xTicks.map(t => `
          <line class="grid-line" x1="${x(t.ts)}" y1="${pad.top}" x2="${x(t.ts)}" y2="${H-pad.bottom}" />
          <text class="axis-label" x="${x(t.ts)-24}" y="${H-20}">${t.label}</text>
        `).join('')}

        <text class="axis-title" x="${W/2-65}" y="${H-6}">Time</text>
        <text class="axis-title" x="20" y="18">pDAI Price (log)</text>

        <g clip-path="url(#plotClip)">
          <path class="price-area" d="${areaPath}" />
          <path class="price-path" d="${path}" />
          ${events.map(e => `<circle class="event-dot" cx="${x(e.ts)}" cy="${y(e.price)}" r="5.2" data-date="${formatDate(e.ts)}" data-price="${formatPrice(e.price)}" data-title="${e.title.replace(/"/g,'&quot;')}"/>`).join('')}
        </g>
      `;

      list.innerHTML = events.map(e => `<div class="event-item"><b>${formatDate(e.ts)}</b>${e.title}</div>`).join('');

      const dots = svg.querySelectorAll('.event-dot');
      const hideTip = () => {
        tooltip.classList.remove('visible');
        tooltip.setAttribute('aria-hidden', 'true');
      };

      dots.forEach(dot => {
        dot.addEventListener('mouseenter', (ev) => {
          const t = ev.currentTarget;
          tooltip.innerHTML = `<div class="tooltip-date">${t.dataset.date}</div><div class="tooltip-price">${t.dataset.price}</div><div>${t.dataset.title}</div>`;
          tooltip.classList.add('visible');
          tooltip.setAttribute('aria-hidden', 'false');
          dot.setAttribute('r', '7.4');
        });
        dot.addEventListener('mousemove', (ev) => {
          const hostRect = svg.parentElement.getBoundingClientRect();
          let px = ev.clientX - hostRect.left;
          let py = ev.clientY - hostRect.top;
          px = Math.min(hostRect.width - 14, Math.max(14, px));
          py = Math.min(hostRect.height - 20, Math.max(34, py));
          tooltip.style.left = `${px}px`;
          tooltip.style.top = `${py}px`;
        });
        dot.addEventListener('mouseleave', () => {
          dot.setAttribute('r', '5.2');
          hideTip();
        });
      });
      svg.addEventListener('mouseleave', hideTip);
    }

    renderTimeline();
  </script>
</body>
</html>
