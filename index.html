<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pDAI Timeline</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; min-height: 100%; background: #000; font-family: Inter, system-ui, sans-serif; color: #dceaff; }
    #canvas-container { position: fixed; inset: 0; }
    .content { position: relative; z-index: 1; width: min(96%, 1280px); margin: 1rem auto 1.5rem; display: grid; gap: 1rem; }
    .window { background: rgba(4, 9, 22, 0.62); border: 1px solid rgba(132, 207, 255, 0.24); border-radius: 18px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45), 0 0 40px rgba(58, 133, 240, 0.2); backdrop-filter: blur(4px); padding: .95rem; }
    .header { display:flex; justify-content:space-between; gap:.8rem; flex-wrap:wrap; padding:.35rem .5rem .65rem; }
    .title { font-size: clamp(1.06rem, 2.4vw, 1.75rem); letter-spacing: .11em; text-transform: uppercase; background: linear-gradient(90deg, #54e5ff, #8f8bff 45%, #ca65ff 90%); -webkit-background-clip:text; color: transparent; }
    .subtitle { color:#a8c3e6; font-size:.83rem; }
    .chart-shell { position: relative; border-radius: 14px; border: 1px solid rgba(143, 200, 255, .2); background: radial-gradient(1200px 320px at 20% 0%, rgba(83, 105, 255, .15), transparent 60%), radial-gradient(920px 300px at 90% 100%, rgba(84, 229, 255, .12), transparent 70%), rgba(3, 12, 29, .62); overflow: hidden; padding: .55rem; }
    svg { width:100%; height:min(67vh,620px); min-height:390px; display:block; }
    #multi-chart { height:min(66vh,600px); min-height:360px; }
    .grid-line { stroke: rgba(130, 170, 230, 0.16); stroke-width: 1; }
    .axis-label { fill: rgba(175, 206, 242, .88); font-size: 11px; }
    .axis-title { fill: rgba(130, 188, 255, .95); font-size: 11px; letter-spacing: .06em; text-transform: uppercase; }
    .price-path { fill: none; stroke: url(#lineGradient); stroke-width: 2.7; stroke-linecap: round; stroke-linejoin: round; filter: drop-shadow(0 0 9px rgba(109, 208, 255, 0.35)); }
    .price-area { fill: url(#areaGradient); }
    .event-dot { fill: #d5f8ff; stroke: rgba(55, 160, 255, 0.95); stroke-width: 1.5; cursor: pointer; }
    .event-dot:hover { filter: drop-shadow(0 0 8px rgba(131, 217, 255, .95)); }
    .toolbar { margin-top: .45rem; display:flex; justify-content:center; }
    .legend { display:flex; flex-wrap:wrap; gap:.4rem; justify-content:center; width:100%; }
    .scale-control-vertical { position:absolute; right:8px; top:50%; transform:translateY(-50%); display:flex; flex-direction:column; align-items:center; gap:.35rem; background:rgba(8,18,40,.55); border:1px solid rgba(126,182,246,.28); border-radius:10px; padding:.42rem .3rem; }
    .scale-control-vertical span { font-size:.68rem; color:#9ec8ef; writing-mode:vertical-rl; transform:rotate(180deg); }
    #scale-slider { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width:16px; height:150px; accent-color:#76d8ff; }
    .chip { border: 1px solid rgba(144, 193, 255, .24); background: rgba(9, 22, 45, .66); color: #c9e7ff; border-radius: 999px; padding: .25rem .55rem; font-size: .75rem; cursor: pointer; }
    .chip.active { border-color: rgba(116, 227, 255, .75); box-shadow: 0 0 12px rgba(92, 206, 255, .22) inset; }
    .tooltip { position: absolute; pointer-events:none; min-width:220px; max-width:min(92vw,390px); background: rgba(8, 18, 40, .95); border: 1px solid rgba(134, 201, 255, .4); border-radius: 10px; color:#dbedff; padding:.62rem .74rem; font-size:.78rem; line-height:1.4; opacity:0; transform: scale(.98); transition: opacity .13s ease, transform .13s ease; box-shadow: 0 14px 25px rgba(0,0,0,.4); z-index:4; }
    .tooltip.visible { opacity:1; transform: scale(1); }
    .tooltip-date { color:#8fb4ff; font-size:.72rem; margin-bottom:.14rem; }
    .tooltip-price { color:#7ce4ff; font-size:.72rem; margin-bottom:.2rem; }
    @media (max-width: 760px) { .window { padding: .65rem; } .chart-shell { padding: .3rem; } svg, #multi-chart { height: 64vh; min-height: 340px; } }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <main class="content">
    <section class="window">
      <div class="header">
        <h1 class="title">pDAI Price Timeline</h1>
        <p class="subtitle">Tooltip-only events • clean quarterly x-axis</p>
      </div>
      <section class="chart-shell">
        <div id="single-chart" aria-label="pDAI chart"></div>
        <div id="single-tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>
      </section>
    </section>

    <section class="window">
      <div class="header">
        <h2 class="title">Multi-Asset Cypherpunk Timeline</h2>
        <p class="subtitle">Wheel zoom • drag pan • click chip/event to focus asset</p>
      </div>
      <section class="chart-shell" id="multi-shell">
        <svg id="multi-chart" viewBox="0 0 1400 700" preserveAspectRatio="xMidYMid meet"></svg>
        <div class="scale-control-vertical">
          <span>Scale</span>
          <input id="scale-slider" type="range" min="50" max="300" step="5" value="140" />
          <span id="scale-value">1.40x</span>
        </div>
        <div id="multi-tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>
      </section>
      <div class="toolbar">
        <div id="multi-legend" class="legend"></div>
      </div>
    </section>
  </main>

  <script src="https://pixijs.download/v6.5.8/pixi.min.js"></script>
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <script>
    const app = new PIXI.Application({ autoDensity:true, antialias:true, backgroundAlpha:0, width:window.innerWidth, height:window.innerHeight, resolution:window.devicePixelRatio||1 });
    document.getElementById('canvas-container').appendChild(app.view);
    app.ticker.maxFPS = 120;
    const CELL = 150; let cols = 0, rows = 0; const grid = [], nodes = [];
    const tmpG = new PIXI.Graphics(); tmpG.beginFill(0xffffff); tmpG.drawCircle(0,0,1.5); tmpG.endFill();
    const nodeTex = app.renderer.generateTexture(tmpG); const COLORS = [0xaa00ff, 0x00aaff, 0x004de6];
    const lines = new PIXI.Graphics(); lines.blendMode = PIXI.BLEND_MODES.ADD; app.stage.addChild(lines);
    let mouse = null; window.addEventListener('mousemove', e => mouse = { x:e.clientX, y:e.clientY }); window.addEventListener('mouseleave', () => mouse = null);

    function initBackground() {
      cols = Math.ceil(app.screen.width / CELL); rows = Math.ceil(app.screen.height / CELL); grid.length = cols * rows;
      for (let i = 0; i < grid.length; i += 1) grid[i] = []; nodes.length = 0; app.stage.removeChildren(); app.stage.addChild(lines);
      const count = Math.floor((app.screen.width * app.screen.height) / 15000 * 1.56);
      for (let i = 0; i < count; i += 1) { const n = new PIXI.Sprite(nodeTex); n.tint = COLORS[i % COLORS.length]; n.anchor.set(0.5); n.x = Math.random()*app.screen.width; n.y = Math.random()*app.screen.height; n.vx = (Math.random()-0.5)*0.51; n.vy = (Math.random()-0.5)*0.51; n.ix=0; n.iy=0; app.stage.addChild(n); nodes.push(n);} }
    app.ticker.add(() => {
      lines.clear(); for (let i = 0; i < grid.length; i += 1) grid[i].length = 0;
      for (const n of nodes) { const idx = Math.floor(n.y / CELL) * cols + Math.floor(n.x / CELL); if (grid[idx]) grid[idx].push(n); }
      for (const a of nodes) {
        const col = Math.floor(a.x / CELL), row = Math.floor(a.y / CELL);
        for (let dy = -1; dy <= 1; dy += 1) for (let dx = -1; dx <= 1; dx += 1) {
          const c = col + dx, r = row + dy; if (c < 0 || c >= cols || r < 0 || r >= rows) continue;
          for (const b of grid[r * cols + c]) { if (a === b) continue; const dX = a.x - b.x, dY = a.y - b.y, dist = Math.hypot(dX, dY); if (dist < CELL) { lines.lineStyle(1.2, a.tint, ((CELL - dist) / CELL) * 0.4); lines.moveTo(a.x,a.y).lineTo(b.x,b.y);} }
        }
      }
      for (const n of nodes) {
        n.x += n.vx + n.ix; n.y += n.vy + n.iy; n.ix *= 0.6; n.iy *= 0.6;
        if (mouse) { const dX = n.x - mouse.x, dY = n.y - mouse.y, dist = Math.hypot(dX, dY); if (dist < CELL && dist > 0.1) { const f = (CELL-dist)/CELL; n.ix += (dX/dist)*5*f; n.iy += (dY/dist)*5*f; } }
        if (n.x < 0 || n.x > app.screen.width) n.vx *= -1; if (n.y < 0 || n.y > app.screen.height) n.vy *= -1;
      }
    });

    const toTs = (d) => new Date(d).getTime();
    const fmtDate = (ts) => new Date(ts).toLocaleDateString(undefined, { year:'numeric', month:'short', day:'numeric' });
    const fmtUsd = (value) => {
      const v = Number(value) || 0;
      if (v >= 1000) return `$${v.toLocaleString(undefined,{maximumFractionDigits:0})}`;
      if (v >= 1) return `$${v.toLocaleString(undefined,{maximumFractionDigits:2})}`;
      if (v === 0) return '$0';
      const decimals = Math.min(12, Math.max(4, Math.ceil(Math.abs(Math.log10(v))) + 2));
      return `$${v.toFixed(decimals).replace(/\.?0+$/, '')}`;
    };
    const timelineTicks = (minTs, maxTs) => {
      const quarters = [];
      const years = [];
      const d = new Date(minTs);
      const qm = Math.floor(d.getUTCMonth()/3)*3;
      let c = Date.UTC(d.getUTCFullYear(), qm, 1);
      if (c < minTs) c = Date.UTC(d.getUTCFullYear(), qm + 3, 1);
      while (c <= maxTs) {
        const t = new Date(c);
        quarters.push({ ts: c });
        if (t.getUTCMonth() === 0) years.push({ ts: c, label: String(t.getUTCFullYear()) });
        c = Date.UTC(t.getUTCFullYear(), t.getUTCMonth()+3,1);
      }
      return { quarters, years };
    };

    const pdaiSeries = [
      ['2023-05-13',0.00005],['2023-08-01',0.00012],['2023-10-01',0.00020],['2023-12-15',0.00045],['2024-02-15',0.00120],['2024-04-01',0.00320],['2024-05-01',0.00780],['2024-06-01',0.00500],['2024-07-01',0.00300],['2024-08-15',0.00120],['2024-10-01',0.00100],['2024-12-01',0.00350],['2025-01-01',0.03280],['2025-01-20',0.01500],['2025-02-10',0.02000],['2025-03-01',0.00900],['2025-03-24',0.00280],['2025-04-10',0.00100],['2025-04-17',0.000002],['2025-05-01',0.00060],['2025-06-01',0.00090],['2025-08-01',0.00105],['2025-10-01',0.00110],['2026-02-01',0.00114]
    ].map(([date,price])=>({ts:toTs(date),price}));
    const pdaiEvents = [['2023-05-13','44.37B pDAI airdropped to ETH holders'],['2025-01-26','PSM exploit period begins'],['2025-03-15','Peak exploit window near $0.034'],['2025-04-17','ESM shutdown crash wick lows'],['2026-02-01','Current zone around $0.00114']].map(([d,t])=>{const ts=toTs(d);const n=pdaiSeries.reduce((a,b)=>Math.abs(b.ts-ts)<Math.abs(a.ts-ts)?b:a,pdaiSeries[0]);return{ts:n.ts,price:n.price,title:t};});

    const assets = {
      pdai: { name:'pDAI', color:'#67d9ff', ghost:'#67d9ff40', series: pdaiSeries, events: pdaiEvents },
      btc: { name:'BTC', color:'#f9c35a', ghost:'#f9c35a40', series:[['2013-01-01',13],['2017-12-17',19783],['2018-12-15',3122],['2021-11-10',68789],['2022-11-10',15500],['2024-03-14',73750]].map(([d,p])=>({ts:toTs(d),price:p})), events:[['2017-12-17','Cycle ATH'],['2021-11-10','ATH'],['2024-03-14','Pre-halving ATH']] },
      eth: { name:'ETH', color:'#c8ceda', ghost:'#c8ceda40', series:[['2015-07-30',0.31],['2018-01-13',1432],['2018-12-15',80],['2021-11-10',4891],['2022-09-15',1450],['2024-01-01',3500]].map(([d,p])=>({ts:toTs(d),price:p})), events:[['2015-07-30','Ethereum mainnet launches'],['2021-11-10','ETH ATH'],['2022-09-15','The Merge']] },
      pls: { name:'PLS', color:'#7f8bff', ghost:'#7f8bff40', series:[['2023-05-13',0.000086],['2023-12-01',0.00006],['2024-12-01',0.00007],['2025-06-01',0.00003]].map(([d,p])=>({ts:toTs(d),price:p})), events:[['2023-05-13','PulseChain mainnet launches'],['2025-06-01','Current low-range state']] }
    };

    for (const key of Object.keys(assets)) if (key !== 'pdai') assets[key].events = assets[key].events.map(([d,t])=>{const ts=toTs(d); const n=assets[key].series.reduce((a,b)=>Math.abs(b.ts-ts)<Math.abs(a.ts-ts)?b:a,assets[key].series[0]); return {ts:n.ts,price:n.price,title:t};});

    const LIVE_CONFIG = {
      pdaiPair: { chain: 'pulsechain', pair: '0x25a72131d02081eef532192e7be1144e139e165e' },
      pollMs: 5000,
      requestTimeoutMs: 4500,
      geckoPool: '0x25a72131d02081eef532192e7be1144e139e165e',
      history: { timeframe: 'hour', aggregate: 1, limit: 1000 },
    };

    function appendLivePoint(assetKey, ts, price) {
      const asset = assets[assetKey];
      if (!asset || !Number.isFinite(price) || price <= 0) return;
      const last = asset.series[asset.series.length - 1];
      if (last && ts - last.ts < 2500) {
        last.ts = ts;
        last.price = price;
      } else {
        asset.series.push({ ts, price });
      }
      const cutoff = ts - (1000 * 60 * 60 * 24 * 365 * 8);
      while (asset.series.length > 2 && asset.series[0].ts < cutoff) asset.series.shift();
    }

    async function fetchJson(url, options = {}) {
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), LIVE_CONFIG.requestTimeoutMs);
      try {
        const res = await fetch(url, { ...options, signal: controller.signal });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } finally {
        clearTimeout(t);
      }
    }

    async function fetchPdaiDexScreenerPrice() {
      const { chain, pair } = LIVE_CONFIG.pdaiPair;
      const data = await fetchJson(`https://api.dexscreener.com/latest/dex/pairs/${chain}/${pair}`);
      const price = Number(data?.pair?.priceUsd);
      if (!Number.isFinite(price) || price <= 0) throw new Error('No valid pDAI DexScreener price');
      return price;
    }

    async function fetchPdaiHistoricalSeries() {
      const { geckoPool, history } = LIVE_CONFIG;
      const url = `https://api.geckoterminal.com/api/v2/networks/pulsechain/pools/${geckoPool}/ohlcv/${history.timeframe}?aggregate=${history.aggregate}&limit=${history.limit}`;
      const data = await fetchJson(url);
      const list = data?.data?.attributes?.ohlcv_list;
      if (!Array.isArray(list) || !list.length) throw new Error('No historical OHLCV data');
      const mapped = list
        .map((row) => ({ ts: Number(row?.[0]) * 1000, price: Number(row?.[4]) }))
        .filter((p) => Number.isFinite(p.ts) && Number.isFinite(p.price) && p.price > 0)
        .sort((a,b) => a.ts - b.ts);
      if (mapped.length < 10) throw new Error('Insufficient historical OHLCV points');
      return mapped;
    }

    async function hydratePdaiHistory() {
      try {
        const series = await fetchPdaiHistoricalSeries();
        assets.pdai.series.length = 0;
        assets.pdai.series.push(...series);

        for (const ev of assets.pdai.events) {
          const nearest = assets.pdai.series.reduce((a, b) => Math.abs(b.ts - ev.ts) < Math.abs(a.ts - ev.ts) ? b : a, assets.pdai.series[0]);
          ev.ts = nearest.ts;
          ev.price = nearest.price;
        }
      } catch (err) {
        console.warn('Historical pDAI load failed, using fallback seed series', err);
      }
    }

    let pollBusy = false;
    async function refreshLiveData() {
      if (pollBusy) return;
      pollBusy = true;
      try {
        const pdai = await fetchPdaiDexScreenerPrice();
        const now = Date.now();
        appendLivePoint('pdai', now, pdai);

        multiState.maxTs = Math.max(...Object.values(assets).flatMap(a=>a.series.map(p=>p.ts)));
        if (multiState.viewEnd >= multiState.maxTs - 20000) {
          const span = multiState.viewEnd - multiState.viewStart;
          multiState.viewEnd = multiState.maxTs;
          multiState.viewStart = Math.max(multiState.minTs, multiState.viewEnd - span);
        }

        drawSingleChart();
        drawMultiChart();
      } catch (err) {
        console.warn('pDAI live refresh failed', err);
      } finally {
        pollBusy = false;
      }
    }

    function placeTooltip(tip, ev, container) {
      const r = container.getBoundingClientRect();
      const tw = tip.offsetWidth || 240;
      const th = tip.offsetHeight || 90;
      let x = ev.clientX - r.left + 14;
      let y = ev.clientY - r.top - th - 10;
      if (y < 8) y = ev.clientY - r.top + 14;
      x = Math.min(r.width - tw - 8, Math.max(8, x));
      y = Math.min(r.height - th - 8, Math.max(8, y));
      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;
    }

    let singleChart;
    let singleSeries;
    let singleResizeObs;

    function toLightweightData(series) {
      return series.map((p) => ({ time: Math.floor(p.ts / 1000), value: p.price }));
    }

    function buildSingleMarkers() {
      return pdaiEvents.map((e) => ({
        time: Math.floor(e.ts / 1000),
        position: 'inBar',
        color: '#7ce4ff',
        shape: 'circle',
        text: e.title,
      }));
    }

    function initSingleChart() {
      const el = document.getElementById('single-chart');
      const tip = document.getElementById('single-tooltip');
      if (!el || singleChart) return;

      singleChart = LightweightCharts.createChart(el, {
        autoSize: true,
        layout: { background: { color: 'transparent' }, textColor: 'rgba(175, 206, 242, .88)' },
        grid: { vertLines: { color: 'rgba(130, 170, 230, 0.16)' }, horzLines: { color: 'rgba(130, 170, 230, 0.16)' } },
        rightPriceScale: { borderColor: 'rgba(130, 170, 230, 0.25)' },
        timeScale: { borderColor: 'rgba(130, 170, 230, 0.25)', timeVisible: true, secondsVisible: false },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        localization: { priceFormatter: (p) => fmtUsd(p) },
      });

      singleSeries = singleChart.addAreaSeries({
        lineColor: '#7cdfff',
        topColor: 'rgba(118,170,255,0.35)',
        bottomColor: 'rgba(118,170,255,0.03)',
        lineWidth: 2,
        priceLineVisible: true,
      });

      singleSeries.setData(toLightweightData(pdaiSeries));
      singleSeries.setMarkers(buildSingleMarkers());
      singleChart.timeScale().fitContent();

      singleChart.subscribeCrosshairMove((param) => {
        if (!param?.point || !param?.time) { tip.classList.remove('visible'); tip.setAttribute('aria-hidden','true'); return; }
        const price = param.seriesData.get(singleSeries)?.value;
        if (!Number.isFinite(price)) { tip.classList.remove('visible'); tip.setAttribute('aria-hidden','true'); return; }
        const ts = Number(param.time) * 1000;
        tip.innerHTML = `<div class="tooltip-date">${fmtDate(ts)}</div><div class="tooltip-price">${fmtUsd(price)}</div>`;
        tip.classList.add('visible');
        tip.setAttribute('aria-hidden','false');
        placeTooltip(tip, { clientX: param.point.x + el.getBoundingClientRect().left, clientY: param.point.y + el.getBoundingClientRect().top }, el.parentElement);
      });

      singleResizeObs = new ResizeObserver(() => singleChart.applyOptions({}));
      singleResizeObs.observe(el);
    }

    function drawSingleChart() {
      initSingleChart();
      if (!singleSeries || !singleChart) return;
      singleSeries.setData(toLightweightData(pdaiSeries));
      singleSeries.setMarkers(buildSingleMarkers());
    }

    const multiState = { focus:'pdai', scaleFactor:1.4, minTs:Math.min(...Object.values(assets).flatMap(a=>a.series.map(p=>p.ts))), maxTs:Math.max(...Object.values(assets).flatMap(a=>a.series.map(p=>p.ts))), viewStart:null, viewEnd:null, dragging:false, lastX:0 };
    multiState.viewEnd = multiState.maxTs; multiState.viewStart = Math.max(multiState.minTs, multiState.maxTs - 1000*60*60*24*365*2.5);

    function drawMultiChart() {
      const svg = document.getElementById('multi-chart'); const tip = document.getElementById('multi-tooltip'); const legend = document.getElementById('multi-legend');
      const W=1400,H=700,pad={top:24,right:72,bottom:58,left:42},innerW=W-pad.left-pad.right,innerH=H-pad.top-pad.bottom;
      const {viewStart,viewEnd,focus}=multiState;
      const x=(ts)=>pad.left+((ts-viewStart)/(viewEnd-viewStart))*innerW;
      const ticks = timelineTicks(viewStart, viewEnd);

      const yUnified = (normValue) => {
        const raw = (Math.log10(Math.max(1e-8, normValue)) + 2) / 4;
        const scaled = ((raw - 0.5) / multiState.scaleFactor) + 0.5;
        return pad.top + (1 - Math.max(0, Math.min(1, scaled))) * innerH;
      };

      const yTickValues = [0.25,0.5,1,2,4,8,16];

      let paths='';
      for (const [k,a] of Object.entries(assets)) {
        const vis=a.series.filter(p=>p.ts>=viewStart&&p.ts<=viewEnd); if (vis.length<2) continue;
        const isFocus=k===focus;
        const base = vis[0].price || a.series.find(v=>v.price>0)?.price || 1;
        const d=vis.map((p,i)=>`${i?'L':'M'} ${x(p.ts).toFixed(2)} ${yUnified(p.price/base).toFixed(2)}`).join(' ');
        paths += `<path d="${d}" fill="none" stroke="${isFocus?a.color:a.ghost}" stroke-width="${isFocus?2.7:1.4}" opacity="${isFocus?1:0.72}" stroke-linecap="round" stroke-linejoin="round"/>`;
      }

      const dots = Object.entries(assets).flatMap(([k,a])=>a.events.filter(e=>e.ts>=viewStart&&e.ts<=viewEnd).map(e=>{
        const isFocus=k===focus;
        const base = a.series.find(v=>v.ts>=viewStart)?.price || a.series.find(v=>v.price>0)?.price || 1;
        const cy=yUnified(e.price/base);
        return `<circle class="event-dot" cx="${x(e.ts)}" cy="${cy}" r="${isFocus?5.2:3.8}" style="fill:${isFocus?a.color:a.ghost};stroke:${isFocus?'#e8f6ff':'#7ca2d7'};opacity:${isFocus?1:0.8}" data-asset="${k}" data-date="${fmtDate(e.ts)}" data-price="${fmtUsd(e.price)}" data-title="${e.title}"/>`;
      })).join('');

      svg.innerHTML = `<defs><clipPath id="plotClip2"><rect x="${pad.left}" y="${pad.top}" width="${innerW}" height="${innerH}"/></clipPath></defs>${yTickValues.map(v=>`<line class="grid-line" x1="${pad.left}" y1="${yUnified(v)}" x2="${W-pad.right}" y2="${yUnified(v)}"/><text class="axis-label" x="${W-pad.right+8}" y="${yUnified(v)+4}">${Math.round(v*100)}%</text>`).join('')}${ticks.quarters.map(t=>`<line class="grid-line" style="opacity:.45" x1="${x(t.ts)}" y1="${pad.top}" x2="${x(t.ts)}" y2="${H-pad.bottom}"/>`).join('')}${ticks.years.map(t=>`<line class="grid-line" style="opacity:.9" x1="${x(t.ts)}" y1="${pad.top}" x2="${x(t.ts)}" y2="${H-pad.bottom}"/><text class="axis-label" x="${x(t.ts)-14}" y="${H-18}">${t.label}</text>`).join('')}<text class="axis-title" x="${W-pad.right+6}" y="14">Relative move vs visible-start price (focus: ${assets[focus].name})</text><g clip-path="url(#plotClip2)">${paths}${dots}</g>`;
      legend.innerHTML = Object.entries(assets).map(([k,a])=>`<button class="chip ${focus===k?'active':''}" data-asset="${k}" style="border-color:${a.color}66">${a.name}</button>`).join('');
      legend.querySelectorAll('.chip').forEach(btn=>btn.addEventListener('click',()=>{multiState.focus=btn.dataset.asset;drawMultiChart();}));

      const hide=()=>{tip.classList.remove('visible');tip.setAttribute('aria-hidden','true');};
      svg.querySelectorAll('.event-dot').forEach(dot=>{
        dot.addEventListener('mouseenter',(ev)=>{const t=ev.currentTarget;tip.innerHTML=`<div class="tooltip-date">${t.dataset.asset.toUpperCase()} • ${t.dataset.date}</div><div class="tooltip-price">${t.dataset.price}</div><div>${t.dataset.title}</div>`;tip.classList.add('visible');tip.setAttribute('aria-hidden','false');});
        dot.addEventListener('mousemove',(ev)=>{placeTooltip(tip, ev, svg.parentElement);});
        dot.addEventListener('click',(ev)=>{multiState.focus=ev.currentTarget.dataset.asset; drawMultiChart();});
        dot.addEventListener('mouseleave',hide);
      });
      svg.addEventListener('mouseleave', hide);
    }

    const slider = document.getElementById('scale-slider'); const scaleValue = document.getElementById('scale-value');
    slider.addEventListener('input',()=>{multiState.scaleFactor=Number(slider.value)/100; scaleValue.textContent=`${multiState.scaleFactor.toFixed(2)}x`; drawMultiChart();});

    const multiShell = document.getElementById('multi-shell');
    multiShell.addEventListener('wheel',(ev)=>{ev.preventDefault();const z=ev.deltaY>0?1.12:0.88;const range=multiState.viewEnd-multiState.viewStart;const rect=multiShell.getBoundingClientRect();const ratio=(ev.clientX-rect.left)/rect.width;const pivot=multiState.viewStart+range*ratio;const nextRange=Math.max(1000*60*60*24*180,Math.min(multiState.maxTs-multiState.minTs,range*z));let s=pivot-nextRange*ratio,e=s+nextRange;if(s<multiState.minTs){s=multiState.minTs;e=s+nextRange;}if(e>multiState.maxTs){e=multiState.maxTs;s=e-nextRange;}multiState.viewStart=s;multiState.viewEnd=e;drawMultiChart();},{passive:false});
    multiShell.addEventListener('pointerdown',(ev)=>{multiState.dragging=true;multiState.lastX=ev.clientX;multiShell.setPointerCapture(ev.pointerId);});
    multiShell.addEventListener('pointermove',(ev)=>{if(!multiState.dragging)return;const rect=multiShell.getBoundingClientRect();const dx=ev.clientX-multiState.lastX;multiState.lastX=ev.clientX;const range=multiState.viewEnd-multiState.viewStart;const delta=-(dx/rect.width)*range;let s=multiState.viewStart+delta,e=multiState.viewEnd+delta;if(s<multiState.minTs){e+=multiState.minTs-s;s=multiState.minTs;}if(e>multiState.maxTs){s-=e-multiState.maxTs;e=multiState.maxTs;}multiState.viewStart=s;multiState.viewEnd=e;drawMultiChart();});
    const stopDrag=()=>{multiState.dragging=false;}; multiShell.addEventListener('pointerup',stopDrag); multiShell.addEventListener('pointercancel',stopDrag);

    window.addEventListener('resize',()=>{app.renderer.resize(window.innerWidth,window.innerHeight);initBackground();drawSingleChart();drawMultiChart();});

    async function bootstrapCharts() {
      initBackground();
      await hydratePdaiHistory();
      drawSingleChart();
      drawMultiChart();
      await refreshLiveData();
      setInterval(refreshLiveData, LIVE_CONFIG.pollMs);
    }

    bootstrapCharts();

  </script>
</body>
</html>
