<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pDAI Timeline</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; min-height: 100%; background: #000; font-family: Inter, system-ui, sans-serif; color: #dceaff; }
    #canvas-container { position: fixed; inset: 0; }
    .content { position: relative; z-index: 1; width: min(96%, 1280px); margin: 1rem auto 1.5rem; display: grid; gap: 1rem; }
    .window { background: rgba(4, 9, 22, 0.62); border: 1px solid rgba(132, 207, 255, 0.24); border-radius: 18px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45), 0 0 40px rgba(58, 133, 240, 0.2); backdrop-filter: blur(4px); padding: .95rem; }
    .header { display:flex; justify-content:space-between; gap:.8rem; flex-wrap:wrap; padding:.35rem .5rem .65rem; }
    .title { font-size: clamp(1.06rem, 2.4vw, 1.75rem); letter-spacing: .11em; text-transform: uppercase; background: linear-gradient(90deg, #54e5ff, #8f8bff 45%, #ca65ff 90%); -webkit-background-clip:text; color: transparent; }
    .subtitle { color:#a8c3e6; font-size:.83rem; }
    .chart-shell { position: relative; border-radius: 14px; border: 1px solid rgba(143, 200, 255, .2); background: radial-gradient(1200px 320px at 20% 0%, rgba(83, 105, 255, .15), transparent 60%), radial-gradient(920px 300px at 90% 100%, rgba(84, 229, 255, .12), transparent 70%), rgba(3, 12, 29, .62); overflow: hidden; padding: .55rem; }
    svg { width:100%; height:min(67vh,620px); min-height:390px; display:block; }
    #multi-chart { height:min(66vh,600px); min-height:360px; }
    .grid-line { stroke: rgba(130, 170, 230, 0.16); stroke-width: 1; }
    .axis-label { fill: rgba(175, 206, 242, .88); font-size: 11px; }
    .axis-title { fill: rgba(130, 188, 255, .95); font-size: 11px; letter-spacing: .06em; text-transform: uppercase; }
    .price-path { fill: none; stroke: url(#lineGradient); stroke-width: 2.7; stroke-linecap: round; stroke-linejoin: round; filter: drop-shadow(0 0 9px rgba(109, 208, 255, 0.35)); }
    .price-area { fill: url(#areaGradient); }
    .event-dot { fill: #d5f8ff; stroke: rgba(55, 160, 255, 0.95); stroke-width: 1.5; cursor: pointer; }
    .event-dot:hover { filter: drop-shadow(0 0 8px rgba(131, 217, 255, .95)); }
    .toolbar { margin-top: .45rem; display:flex; justify-content:center; }
    .legend { display:flex; flex-wrap:wrap; gap:.4rem; justify-content:center; width:100%; }
    .scale-control-vertical { position:absolute; right:8px; top:50%; transform:translateY(-50%); display:flex; flex-direction:column; align-items:center; gap:.35rem; background:rgba(8,18,40,.55); border:1px solid rgba(126,182,246,.28); border-radius:10px; padding:.42rem .3rem; }
    .scale-control-vertical span { font-size:.68rem; color:#9ec8ef; writing-mode:vertical-rl; transform:rotate(180deg); }
    #scale-slider { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width:16px; height:150px; accent-color:#76d8ff; }
    .chip { border: 1px solid rgba(144, 193, 255, .24); background: rgba(9, 22, 45, .66); color: #c9e7ff; border-radius: 999px; padding: .25rem .55rem; font-size: .75rem; cursor: pointer; }
    .chip.active { border-color: rgba(116, 227, 255, .75); box-shadow: 0 0 12px rgba(92, 206, 255, .22) inset; }
    .tooltip { position: absolute; pointer-events:none; min-width:220px; max-width:min(92vw,390px); background: rgba(8, 18, 40, .95); border: 1px solid rgba(134, 201, 255, .4); border-radius: 10px; color:#dbedff; padding:.62rem .74rem; font-size:.78rem; line-height:1.4; opacity:0; transform: scale(.98); transition: opacity .13s ease, transform .13s ease; box-shadow: 0 14px 25px rgba(0,0,0,.4); z-index:4; }
    .tooltip.visible { opacity:1; transform: scale(1); }
    .tooltip-date { color:#8fb4ff; font-size:.72rem; margin-bottom:.14rem; }
    .tooltip-price { color:#7ce4ff; font-size:.72rem; margin-bottom:.2rem; }
    @media (max-width: 760px) { .window { padding: .65rem; } .chart-shell { padding: .3rem; } svg, #multi-chart { height: 64vh; min-height: 340px; } }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <main class="content">
    <section class="window">
      <div class="header">
        <h1 class="title">pDAI Price Timeline</h1>
        <p class="subtitle">Tooltip-only events • clean quarterly x-axis</p>
      </div>
      <section class="chart-shell">
        <svg id="single-chart" viewBox="0 0 1400 740" preserveAspectRatio="xMidYMid meet"></svg>
        <div id="single-tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>
      </section>
    </section>

    <section class="window">
      <div class="header">
        <h2 class="title">Multi-Asset Cypherpunk Timeline</h2>
        <p class="subtitle">Wheel zoom • drag pan • click chip/event to focus asset</p>
      </div>
      <section class="chart-shell" id="multi-shell">
        <svg id="multi-chart" viewBox="0 0 1400 700" preserveAspectRatio="xMidYMid meet"></svg>
        <div class="scale-control-vertical">
          <span>Scale</span>
          <input id="scale-slider" type="range" min="50" max="300" step="5" value="140" />
          <span id="scale-value">1.40x</span>
        </div>
        <div id="multi-tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>
      </section>
      <div class="toolbar">
        <div id="multi-legend" class="legend"></div>
      </div>
    </section>
  </main>

  <script src="https://pixijs.download/v6.5.8/pixi.min.js"></script>
  <script>
    const app = new PIXI.Application({ autoDensity:true, antialias:true, backgroundAlpha:0, width:window.innerWidth, height:window.innerHeight, resolution:window.devicePixelRatio||1 });
    document.getElementById('canvas-container').appendChild(app.view);
    app.ticker.maxFPS = 120;
    const CELL = 150; let cols = 0, rows = 0; const grid = [], nodes = [];
    const tmpG = new PIXI.Graphics(); tmpG.beginFill(0xffffff); tmpG.drawCircle(0,0,1.5); tmpG.endFill();
    const nodeTex = app.renderer.generateTexture(tmpG); const COLORS = [0xaa00ff, 0x00aaff, 0x004de6];
    const lines = new PIXI.Graphics(); lines.blendMode = PIXI.BLEND_MODES.ADD; app.stage.addChild(lines);
    let mouse = null; window.addEventListener('mousemove', e => mouse = { x:e.clientX, y:e.clientY }); window.addEventListener('mouseleave', () => mouse = null);

    function initBackground() {
      cols = Math.ceil(app.screen.width / CELL); rows = Math.ceil(app.screen.height / CELL); grid.length = cols * rows;
      for (let i = 0; i < grid.length; i += 1) grid[i] = []; nodes.length = 0; app.stage.removeChildren(); app.stage.addChild(lines);
      const count = Math.floor((app.screen.width * app.screen.height) / 15000 * 1.56);
      for (let i = 0; i < count; i += 1) { const n = new PIXI.Sprite(nodeTex); n.tint = COLORS[i % COLORS.length]; n.anchor.set(0.5); n.x = Math.random()*app.screen.width; n.y = Math.random()*app.screen.height; n.vx = (Math.random()-0.5)*0.51; n.vy = (Math.random()-0.5)*0.51; n.ix=0; n.iy=0; app.stage.addChild(n); nodes.push(n);} }
    app.ticker.add(() => {
      lines.clear(); for (let i = 0; i < grid.length; i += 1) grid[i].length = 0;
      for (const n of nodes) { const idx = Math.floor(n.y / CELL) * cols + Math.floor(n.x / CELL); if (grid[idx]) grid[idx].push(n); }
      for (const a of nodes) {
        const col = Math.floor(a.x / CELL), row = Math.floor(a.y / CELL);
        for (let dy = -1; dy <= 1; dy += 1) for (let dx = -1; dx <= 1; dx += 1) {
          const c = col + dx, r = row + dy; if (c < 0 || c >= cols || r < 0 || r >= rows) continue;
          for (const b of grid[r * cols + c]) { if (a === b) continue; const dX = a.x - b.x, dY = a.y - b.y, dist = Math.hypot(dX, dY); if (dist < CELL) { lines.lineStyle(1.2, a.tint, ((CELL - dist) / CELL) * 0.4); lines.moveTo(a.x,a.y).lineTo(b.x,b.y);} }
        }
      }
      for (const n of nodes) {
        n.x += n.vx + n.ix; n.y += n.vy + n.iy; n.ix *= 0.6; n.iy *= 0.6;
        if (mouse) { const dX = n.x - mouse.x, dY = n.y - mouse.y, dist = Math.hypot(dX, dY); if (dist < CELL && dist > 0.1) { const f = (CELL-dist)/CELL; n.ix += (dX/dist)*5*f; n.iy += (dY/dist)*5*f; } }
        if (n.x < 0 || n.x > app.screen.width) n.vx *= -1; if (n.y < 0 || n.y > app.screen.height) n.vy *= -1;
      }
    });

    const toTs = (d) => new Date(d).getTime();
    const fmtDate = (ts) => new Date(ts).toLocaleDateString(undefined, { year:'numeric', month:'short', day:'numeric' });
    const fmtUsd = (v) => { if (v >= 1000) return `$${v.toLocaleString(undefined,{maximumFractionDigits:0})}`; if (v >= 1) return `$${v.toLocaleString(undefined,{maximumFractionDigits:2})}`; if (v >= 0.01) return `$${v.toFixed(4)}`; if (v >= 0.0001) return `$${v.toFixed(6)}`; return `$${v.toExponential(2)}`; };
    const timelineTicks = (minTs, maxTs) => {
      const quarters = [];
      const years = [];
      const d = new Date(minTs);
      const qm = Math.floor(d.getUTCMonth()/3)*3;
      let c = Date.UTC(d.getUTCFullYear(), qm, 1);
      if (c < minTs) c = Date.UTC(d.getUTCFullYear(), qm + 3, 1);
      while (c <= maxTs) {
        const t = new Date(c);
        quarters.push({ ts: c });
        if (t.getUTCMonth() === 0) years.push({ ts: c, label: String(t.getUTCFullYear()) });
        c = Date.UTC(t.getUTCFullYear(), t.getUTCMonth()+3,1);
      }
      return { quarters, years };
    };

    const pdaiSeries = [
      ['2023-05-13',0.00005],['2023-08-01',0.00012],['2023-10-01',0.00020],['2023-12-15',0.00045],['2024-02-15',0.00120],['2024-04-01',0.00320],['2024-05-01',0.00780],['2024-06-01',0.00500],['2024-07-01',0.00300],['2024-08-15',0.00120],['2024-10-01',0.00100],['2024-12-01',0.00350],['2025-01-01',0.03280],['2025-01-20',0.01500],['2025-02-10',0.02000],['2025-03-01',0.00900],['2025-03-24',0.00280],['2025-04-10',0.00100],['2025-04-17',0.000002],['2025-05-01',0.00060],['2025-06-01',0.00090],['2025-08-01',0.00105],['2025-10-01',0.00110],['2026-02-01',0.00114]
    ].map(([date,price])=>({ts:toTs(date),price}));
    const pdaiEvents = [['2023-05-13','44.37B pDAI airdropped to ETH holders'],['2025-01-26','PSM exploit period begins'],['2025-03-15','Peak exploit window near $0.034'],['2025-04-17','ESM shutdown crash wick lows'],['2026-02-01','Current zone around $0.00114']].map(([d,t])=>{const ts=toTs(d);const n=pdaiSeries.reduce((a,b)=>Math.abs(b.ts-ts)<Math.abs(a.ts-ts)?b:a,pdaiSeries[0]);return{ts:n.ts,price:n.price,title:t};});

    function placeTooltip(tip, ev, container) {
      const r = container.getBoundingClientRect();
      const tw = tip.offsetWidth || 240;
      const th = tip.offsetHeight || 90;
      let x = ev.clientX - r.left + 14;
      let y = ev.clientY - r.top - th - 10;
      if (y < 8) y = ev.clientY - r.top + 14;
      x = Math.min(r.width - tw - 8, Math.max(8, x));
      y = Math.min(r.height - th - 8, Math.max(8, y));
      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;
    }

    function drawSingleChart() {
      const svg = document.getElementById('single-chart'); const tip = document.getElementById('single-tooltip'); const W = 1400, H = 740;
      const pad = { top: 24, right: 62, bottom: 64, left: 68 }, innerW = W - pad.left - pad.right, innerH = H - pad.top - pad.bottom;
      const minTs = pdaiSeries[0].ts, maxTs = pdaiSeries[pdaiSeries.length-1].ts, minP = 0, maxP = 0.035;
      const x = (ts)=>pad.left+((ts-minTs)/(maxTs-minTs))*innerW, y=(p)=>pad.top+(1-((p-minP)/(maxP-minP)))*innerH;
      const path = pdaiSeries.map((p,i)=>`${i?'L':'M'} ${x(p.ts).toFixed(2)} ${y(p.price).toFixed(2)}`).join(' ');
      const areaPath = `${path} L ${x(maxTs).toFixed(2)} ${H-pad.bottom} L ${x(minTs).toFixed(2)} ${H-pad.bottom} Z`;
      svg.innerHTML = `<defs><linearGradient id="lineGradient" x1="0" y1="0" x2="1" y2="0"><stop offset="0%" stop-color="#66e0ff"/><stop offset="45%" stop-color="#8f8bff"/><stop offset="100%" stop-color="#d36cff"/></linearGradient><linearGradient id="areaGradient" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="rgba(118,170,255,0.35)"/><stop offset="100%" stop-color="rgba(118,170,255,0.03)"/></linearGradient><clipPath id="plotClip1"><rect x="${pad.left}" y="${pad.top}" width="${innerW}" height="${innerH}"/></clipPath></defs>
      ${[0,0.005,0.01,0.015,0.02,0.025,0.03,0.035].map(v=>`<line class="grid-line" x1="${pad.left}" y1="${y(v)}" x2="${W-pad.right}" y2="${y(v)}"/><text class="axis-label" x="${W-pad.right+10}" y="${y(v)+4}">${fmtUsd(v)}</text>`).join('')}
      ${timelineTicks(minTs,maxTs).quarters.map(t=>`<line class=\"grid-line\" style=\"opacity:.45\" x1=\"${x(t.ts)}\" y1=\"${pad.top}\" x2=\"${x(t.ts)}\" y2=\"${H-pad.bottom}\"/>`).join('')}${timelineTicks(minTs,maxTs).years.map(t=>`<line class=\"grid-line\" style=\"opacity:.9\" x1=\"${x(t.ts)}\" y1=\"${pad.top}\" x2=\"${x(t.ts)}\" y2=\"${H-pad.bottom}\"/><text class=\"axis-label\" x=\"${x(t.ts)-14}\" y=\"${H-20}\">${t.label}</text>`).join('')}
      <text class="axis-title" x="${W-pad.right+8}" y="14">pDAI USD</text><g clip-path="url(#plotClip1)"><path class="price-area" d="${areaPath}"/><path class="price-path" d="${path}"/>${pdaiEvents.map(e=>`<circle class="event-dot" cx="${x(e.ts)}" cy="${y(e.price)}" r="5.2" data-date="${fmtDate(e.ts)}" data-price="${fmtUsd(e.price)}" data-title="${e.title}"/>`).join('')}</g>`;
      const hide=()=>{tip.classList.remove('visible');tip.setAttribute('aria-hidden','true');};
      svg.querySelectorAll('.event-dot').forEach(dot=>{dot.addEventListener('mouseenter',(ev)=>{const t=ev.currentTarget;tip.innerHTML=`<div class="tooltip-date">${t.dataset.date}</div><div class="tooltip-price">${t.dataset.price}</div><div>${t.dataset.title}</div>`;tip.classList.add('visible');dot.setAttribute('r','7');});dot.addEventListener('mousemove',(ev)=>{placeTooltip(tip, ev, svg.parentElement);});dot.addEventListener('mouseleave',()=>{dot.setAttribute('r','5.2');hide();});});
      svg.addEventListener('mouseleave', hide);
    }

    const assets = {
      pdai: { name:'pDAI', color:'#67d9ff', ghost:'#67d9ff40', series: pdaiSeries, events: pdaiEvents },
      btc: { name:'BTC', color:'#f9c35a', ghost:'#f9c35a40', series:[['2009-01-03',0],['2011-06-01',32],['2015-01-01',175],['2017-12-17',19783],['2018-12-15',3122],['2021-11-10',68789],['2022-11-10',15500],['2024-03-14',73750],['2025-01-01',100000],['2026-02-01',96000]].map(([d,p])=>({ts:toTs(d),price:p})), events:[['2009-01-03','Genesis Block mined'],['2017-12-17','Cycle ATH'],['2021-11-10','ATH'],['2024-03-14','Pre-halving ATH']] },
      eth: { name:'ETH', color:'#c8ceda', ghost:'#c8ceda40', series:[['2015-07-30',0.31],['2018-01-13',1432],['2018-12-15',80],['2021-11-10',4891],['2022-09-15',1450],['2024-01-01',3500],['2026-02-01',2700]].map(([d,p])=>({ts:toTs(d),price:p})), events:[['2015-07-30','Ethereum mainnet launches'],['2021-11-10','ETH ATH'],['2022-09-15','The Merge']] },
      hex: { name:'HEX', color:'#ff64d9', ghost:'#ff64d940', series:[['2019-12-02',0.00002],['2020-08-01',0.006],['2021-09-19',0.55],['2022-11-01',0.005],['2024-01-01',0.008],['2026-02-01',0.008]].map(([d,p])=>({ts:toTs(d),price:p})), events:[['2019-12-02','HEX launches'],['2021-09-19','HEX ATH']] },
      pls: { name:'PLS', color:'#7f8bff', ghost:'#7f8bff40', series:[['2023-05-13',0.000086],['2023-12-01',0.00006],['2024-12-01',0.00007],['2025-06-01',0.00003],['2026-02-01',0.000017]].map(([d,p])=>({ts:toTs(d),price:p})), events:[['2023-05-13','PulseChain mainnet launches'],['2026-02-01','Current low-range state']] }
    };
    for (const key of Object.keys(assets)) if (key !== 'pdai') assets[key].events = assets[key].events.map(([d,t])=>{const ts=toTs(d); const n=assets[key].series.reduce((a,b)=>Math.abs(b.ts-ts)<Math.abs(a.ts-ts)?b:a,assets[key].series[0]); return {ts:n.ts,price:n.price,title:t};});

    const multiState = { focus:'pdai', scaleFactor:1.4, minTs:Math.min(...Object.values(assets).flatMap(a=>a.series.map(p=>p.ts))), maxTs:Math.max(...Object.values(assets).flatMap(a=>a.series.map(p=>p.ts))), viewStart:null, viewEnd:null, dragging:false, lastX:0 };
    multiState.viewStart = multiState.minTs; multiState.viewEnd = multiState.maxTs;

    function drawMultiChart() {
      const svg = document.getElementById('multi-chart'); const tip = document.getElementById('multi-tooltip'); const legend = document.getElementById('multi-legend');
      const W=1400,H=700,pad={top:24,right:72,bottom:58,left:42},innerW=W-pad.left-pad.right,innerH=H-pad.top-pad.bottom;
      const {viewStart,viewEnd,focus}=multiState;
      const x=(ts)=>pad.left+((ts-viewStart)/(viewEnd-viewStart))*innerW;
      const ticks = timelineTicks(viewStart, viewEnd);

      const yUnified = (normValue) => {
        const raw = (Math.log10(Math.max(1e-6, normValue)) + 2) / 4;
        const scaled = ((raw - 0.5) / multiState.scaleFactor) + 0.5;
        const clamped = Math.max(0, Math.min(1, scaled));
        return pad.top + (1 - clamped) * innerH;
      };

      const yTickValues = [0.25,0.5,1,2,4,8,16];

      let paths='';
      for (const [k,a] of Object.entries(assets)) {
        const vis=a.series.filter(p=>p.ts>=viewStart&&p.ts<=viewEnd); if (vis.length<2) continue;
        const isFocus=k===focus;
        const base = a.series.find(v=>v.price>0)?.price || 1;
        const pts=vis.map(p=>`${x(p.ts).toFixed(2)} ${yUnified(p.price/base).toFixed(2)}`);
        const d=pts.map((pt,i)=>`${i?'L':'M'} ${pt}`).join(' ');
        paths += `<path d="${d}" fill="none" stroke="${isFocus?a.color:a.ghost}" stroke-width="${isFocus?2.7:1.4}" opacity="${isFocus?1:0.72}" stroke-linecap="round" stroke-linejoin="round"/>`;
      }

      const dots = Object.entries(assets).flatMap(([k,a])=>a.events.filter(e=>e.ts>=viewStart&&e.ts<=viewEnd).map(e=>{
        const isFocus=k===focus;
        const base = a.series.find(v=>v.price>0)?.price || 1;
        const cy=yUnified(e.price/base);
        return `<circle class="event-dot" cx="${x(e.ts)}" cy="${cy}" r="${isFocus?5.2:3.8}" style="fill:${isFocus?a.color:a.ghost};stroke:${isFocus?'#e8f6ff':'#7ca2d7'};opacity:${isFocus?1:0.8}" data-asset="${k}" data-date="${fmtDate(e.ts)}" data-price="${fmtUsd(e.price)}" data-title="${e.title}"/>`;
      })).join('');

      svg.innerHTML = `<defs><clipPath id="plotClip2"><rect x="${pad.left}" y="${pad.top}" width="${innerW}" height="${innerH}"/></clipPath></defs>${yTickValues.map(v=>`<line class="grid-line" x1="${pad.left}" y1="${yUnified(v)}" x2="${W-pad.right}" y2="${yUnified(v)}"/><text class="axis-label" x="${W-pad.right+8}" y="${yUnified(v)+4}">${v}x</text>`).join('')}${ticks.quarters.map(t=>`<line class="grid-line" style="opacity:.45" x1="${x(t.ts)}" y1="${pad.top}" x2="${x(t.ts)}" y2="${H-pad.bottom}"/>`).join('')}${ticks.years.map(t=>`<line class="grid-line" style="opacity:.9" x1="${x(t.ts)}" y1="${pad.top}" x2="${x(t.ts)}" y2="${H-pad.bottom}"/><text class="axis-label" x="${x(t.ts)-14}" y="${H-18}">${t.label}</text>`).join('')}<text class="axis-title" x="${W-pad.right+6}" y="14">Normalized scale (focus: ${assets[focus].name})</text><g clip-path="url(#plotClip2)">${paths}${dots}</g>`;
      legend.innerHTML = Object.entries(assets).map(([k,a])=>`<button class="chip ${focus===k?'active':''}" data-asset="${k}" style="border-color:${a.color}66">${a.name}</button>`).join('');
      legend.querySelectorAll('.chip').forEach(btn=>btn.addEventListener('click',()=>{multiState.focus=btn.dataset.asset;drawMultiChart();}));

      const hide=()=>{tip.classList.remove('visible');tip.setAttribute('aria-hidden','true');};
      svg.querySelectorAll('.event-dot').forEach(dot=>{
        dot.addEventListener('mouseenter',(ev)=>{const t=ev.currentTarget;tip.innerHTML=`<div class="tooltip-date">${t.dataset.asset.toUpperCase()} • ${t.dataset.date}</div><div class="tooltip-price">${t.dataset.price}</div><div>${t.dataset.title}</div>`;tip.classList.add('visible');tip.setAttribute('aria-hidden','false');});
        dot.addEventListener('mousemove',(ev)=>{placeTooltip(tip, ev, svg.parentElement);});
        dot.addEventListener('click',(ev)=>{multiState.focus=ev.currentTarget.dataset.asset; drawMultiChart();});
        dot.addEventListener('mouseleave',hide);
      });
      svg.addEventListener('mouseleave', hide);
    }

    const slider = document.getElementById('scale-slider'); const scaleValue = document.getElementById('scale-value');
    slider.addEventListener('input',()=>{multiState.scaleFactor=Number(slider.value)/100; scaleValue.textContent=`${multiState.scaleFactor.toFixed(2)}x`; drawMultiChart();});

    const multiShell = document.getElementById('multi-shell');
    multiShell.addEventListener('wheel',(ev)=>{ev.preventDefault();const z=ev.deltaY>0?1.12:0.88;const range=multiState.viewEnd-multiState.viewStart;const rect=multiShell.getBoundingClientRect();const ratio=(ev.clientX-rect.left)/rect.width;const pivot=multiState.viewStart+range*ratio;const nextRange=Math.max(1000*60*60*24*180,Math.min(multiState.maxTs-multiState.minTs,range*z));let s=pivot-nextRange*ratio,e=s+nextRange;if(s<multiState.minTs){s=multiState.minTs;e=s+nextRange;}if(e>multiState.maxTs){e=multiState.maxTs;s=e-nextRange;}multiState.viewStart=s;multiState.viewEnd=e;drawMultiChart();},{passive:false});
    multiShell.addEventListener('pointerdown',(ev)=>{multiState.dragging=true;multiState.lastX=ev.clientX;multiShell.setPointerCapture(ev.pointerId);});
    multiShell.addEventListener('pointermove',(ev)=>{if(!multiState.dragging)return;const rect=multiShell.getBoundingClientRect();const dx=ev.clientX-multiState.lastX;multiState.lastX=ev.clientX;const range=multiState.viewEnd-multiState.viewStart;const delta=-(dx/rect.width)*range;let s=multiState.viewStart+delta,e=multiState.viewEnd+delta;if(s<multiState.minTs){e+=multiState.minTs-s;s=multiState.minTs;}if(e>multiState.maxTs){s-=e-multiState.maxTs;e=multiState.maxTs;}multiState.viewStart=s;multiState.viewEnd=e;drawMultiChart();});
    const stopDrag=()=>{multiState.dragging=false;}; multiShell.addEventListener('pointerup',stopDrag); multiShell.addEventListener('pointercancel',stopDrag);

    window.addEventListener('resize',()=>{app.renderer.resize(window.innerWidth,window.innerHeight);initBackground();drawSingleChart();drawMultiChart();});
    initBackground(); drawSingleChart(); drawMultiChart();
  </script>
</body>
</html>
